# 기술적 제약사항 및 보완 방안

## 문서 개요

본 문서는 블루 아카이브 자동화 테스트 프로젝트의 기술적 제약사항, 미구현 항목, 그리고 가능한 보완 방안을 정리합니다.

**프로젝트**: 블루 아카이브 자동화 테스트
**작성일**: 2026-01-08
**버전**: 1.0

---

## 1. 근본적 제약사항

### 1.1 게임 내부 로직 접근 불가

#### 제약 내용
- **문제**: Live 빌드에서는 게임 내부 코드, 메모리, API에 접근할 수 없음
- **영향**:
  - 정확한 HP, 데미지 수치 읽기 불가
  - 캐릭터 상태 (버프, 디버프) 확인 불가
  - 스킬 쿨다운 정확한 추적 불가
  - 전투 로직 내부 변수 접근 불가

#### 현재 대응 방식
- 화면 인식 기반으로 우회 (템플릿 매칭 + OCR)
- 간접적 검증 (UI 출현/소멸, 코스트 차감 등)

#### 보완 가능한 대안
- **개발/테스트 빌드 접근 가능 시**:
  - 게임 로그 파일 파싱
  - Debug API 활용
  - 메모리 덤프 분석 (치트 방지 정책 허용 범위 내)

- **공식 API 제공 시**:
  - REST API로 전투 결과 조회
  - WebSocket으로 실시간 상태 수신
  - 테스트 전용 엔드포인트 활용

---

### 1.2 메모리 조작 금지

#### 제약 내용
- **문제**: 치트 방지 정책으로 메모리 읽기/쓰기 금지
- **영향**:
  - 게임 속도 조절 불가 (빠른 테스트 불가)
  - 특정 상태로 강제 전환 불가
  - 디버그 모드 활성화 불가

#### 현재 대응 방식
- 실제 게임 플레이 속도로 테스트 진행
- 대기 시간 충분히 확보 (네트워크 지연 고려)

#### 보완 가능한 대안
- **테스트 환경 제공 시**:
  - 샌드박스 환경에서 메모리 접근 허용
  - 테스트 전용 빌드 (치트 방지 비활성화)
  - 에뮬레이터 기반 테스트 (속도 조절 가능)

---

## 2. 화면 인식 기반 제약사항

### 2.1 템플릿 매칭 신뢰도 문제

#### 제약 내용
- **문제**: 동적 화면 요소는 템플릿 매칭 정확도 저하
- **영향 받는 요소**:
  - 발판 타일 (적 위치 변동, 애니메이션)
  - 스킬 이펙트 중 UI 가려짐
  - 캐릭터 모션으로 인한 화면 흔들림

#### 현재 대응 방식
- 동적 요소는 **낮은 신뢰도 임계값** 사용:
  - `enemy_tile.png`: 0.5 (기본 0.8 대신)
  - `empty_tile.png`: 0.5
- 재시도 로직 (최대 3회)
- 안정화 대기 시간 추가 (2-3초)

#### 실패 사례
- 스킬 이펙트가 코스트 UI를 완전히 가리는 경우
- 적 타일이 애니메이션 중일 때 인식 실패
- 화면 전환 중 과도기 상태에서 오인식

#### 보완 가능한 대안
- **개선된 인식 기술**:
  - 딥러닝 기반 객체 탐지 (YOLO, EfficientDet)
  - 다중 템플릿 매칭 (같은 요소의 여러 상태 준비)
  - 특징점 기반 매칭 (SIFT, ORB)

- **게임 지원 시**:
  - UI 요소에 고유 ID 부여 (접근성 API)
  - 테스트 모드에서 애니메이션 비활성화
  - 스크린 리더 API 활용

---

### 2.2 해상도 의존성

#### 제약 내용
- **문제**: 템플릿 이미지와 OCR 좌표는 특정 해상도 기준
- **현재 지원**:
  - 2560x1440 (주 해상도)
  - 1920x1080 (부분 지원)
- **영향**:
  - 다른 해상도 사용 시 인식 실패
  - 좌표 재설정 필요

#### 현재 대응 방식
- 해상도별 템플릿 디렉토리 분리:
  ```
  assets/templates/
  ├── 2560x1440/
  └── 1920x1080/
  ```
- 템플릿 자동 스케일링 시스템 (TemplateMatcher)
- GUI에서 해상도 선택 기능

#### 한계
- 완벽한 스케일링 어려움 (특히 작은 UI)
- OCR 좌표는 수동 재설정 필요
- 비표준 해상도 지원 불가

#### 보완 가능한 대안
- **상대 좌표 시스템**:
  - 화면 비율 기반 좌표 계산
  - 앵커 포인트 기반 동적 조정

- **자동 캘리브레이션**:
  - 첫 실행 시 UI 요소 자동 탐지
  - 사용자가 수동으로 영역 지정
  - 설정 파일로 저장 및 재사용

---

### 2.3 코스트 인식 방식 전환 (OCR → 템플릿 매칭)

#### 초기 시도: Tesseract OCR
**문제점**:
- **게임 UI 특성**: 흰색 숫자 + 짙은 남색 원형 배경 + 흰색 외곽선 + 커스텀 폰트
- **Tesseract 한계**: 문서용 OCR로 설계되어 게임 UI에 부적합
- **오류 사례**:
  - "8"을 "3"으로 오인식
  - "6"과 "5" 혼동
  - 작은 폰트 인식 실패
  - 배경 노이즈 영향

**시도한 최적화**:
- 다중 PSM 모드 (7, 8, 6, 13, 3)
- 이미지 전처리 (그레이스케일, 임계값, 노이즈 제거, 3배 스케일업)
- 빈도 기반 필터링 (5회 재시도)

**결론**: 전처리를 아무리 해도 **근본적으로 불안정**

---

#### 현재 방식: 템플릿 기반 분류 (✅ 채택)

**변경 이유**:
1. **게임 코스트 특성**:
   - 값 범위: 2~5 (고정)
   - 시각적 패턴: 아이콘처럼 인식 가능
   - 각 숫자가 고유한 시각적 형태

2. **프로젝트 철학과 일치**:
   - 이미 사용 중인 템플릿 매칭 방식 (pyautogui)
   - 순수 화면 인식 기반 (Live 빌드 제약 준수)
   - 다른 UI 요소들과 통일된 접근

**구현 방식**:
```python
class CostRecognizer:
    """템플릿 매칭 기반 코스트 인식"""

    def __init__(self):
        # 코스트 템플릿 로드 (cost_2.png ~ cost_5.png)
        self.templates = self._load_templates()

    def recognize_cost(self, roi_image):
        # 1. 전처리: HSV 색상 필터로 흰색 숫자 추출
        # 2. 템플릿 매칭 (TM_CCOEFF_NORMED)
        # 3. 가장 높은 신뢰도의 숫자 반환
```

**전처리** (게임 UI 특화):
- HSV 색상 마스크로 흰색 영역만 추출
- 파란 배경 제거
- 모폴로지 연산 (노이즈 제거, 숫자 두께 정규화)

**장점**:
- ✅ **안정성**: 고정된 시각적 패턴 인식
- ✅ **정확도**: OCR보다 훨씬 높음 (0.9+ 신뢰도)
- ✅ **단순성**: Tesseract 의존성 제거
- ✅ **일관성**: 다른 UI 요소와 동일한 템플릿 매칭 방식
- ✅ **과제 적합성**: QA 자동화 과제의 정석 접근

**제약사항**:
- 템플릿 이미지 준비 필요 (cost_2~5.png)
- 해상도별 템플릿 필요 (2560x1440, 1920x1080 등)

#### 참고: OCR 코드 보존
- OCRReader 클래스는 유지 (src/ocr/ocr_reader.py)
- 향후 다른 UI 요소 읽기에 활용 가능
- 문서화 목적으로 보존

---

## 3. 미구현 기능

### 3.1 실시간 데미지 캡처

#### 미구현 이유
**기술적 한계**:
1. 데미지 숫자가 화면에 짧은 시간만 표시 (0.5-1초)
2. 여러 캐릭터의 데미지가 동시 출력
3. 크리티컬, 일반 공격 등 폰트/색상 다양
4. 빠른 전투에서 OCR 처리 시간 부족

**시도한 방식**:
- 화면 연속 캡처 (초당 10프레임) → 성능 저하
- OCR 실시간 처리 → 정확도 30% 이하
- 템플릿 매칭으로 데미지 숫자 인식 → 모든 숫자 조합 준비 불가능

#### 현재 대응 방식
- 데미지 **직접 읽기 대신** 간접 검증:
  - 전투 종료 후 통계 화면 확인
  - 데미지 기록 팝업 출현 여부 확인
  - Victory 달성 여부로 성공 판단

#### 보완 가능한 대안
- **개발 빌드 접근 시**:
  - 전투 로그 파일에서 데미지 값 파싱
  - Debug API로 누적 데미지 조회
  - JSON 형태로 전투 기록 저장

- **공식 API 제공 시**:
  - 전투 종료 후 API로 상세 통계 조회
  - 실시간 이벤트 스트림 수신

- **비디오 분석**:
  - 전투 녹화 후 프레임별 OCR 처리
  - 딥러닝으로 데미지 숫자 탐지 및 인식
  - 후처리로 통계 집계

---

### 3.2 스킬 쿨다운 추적

#### 미구현 이유
**기술적 한계**:
1. 쿨다운 타이머가 시각적으로만 표시 (숫자 없음)
2. 원형 게이지 형태로 OCR 불가능
3. 템플릿 매칭으로 게이지 비율 측정 어려움

**시도한 방식**:
- 스킬 버튼 그레이스케일 분석 → 조명 변화에 민감
- 타이머 숫자 인식 → 숫자 표시 없음
- 쿨다운 상태 템플릿 매칭 → 연속적 변화라 불가능

#### 현재 대응 방식
- 스킬 쿨다운 **추적하지 않음**
- 스킬 사용 시도만 하고 실패 허용
- 코스트만 검증 (쿨다운은 무시)

#### 실제 영향
- 쿨다운 중인 스킬 사용 시도 시:
  - 게임에서 자동으로 무시됨
  - 코스트 차감 안 됨
  - 테스트에 큰 영향 없음

#### 보완 가능한 대안
- **타이머 로직 추가**:
  - 스킬 사용 시점 기록
  - 쿨다운 시간 설정 파일로 관리
  - 경과 시간 계산하여 사용 가능 여부 판단

- **개발 빌드 접근 시**:
  - Debug API로 쿨다운 상태 조회
  - 게임 로그에서 쿨다운 완료 이벤트 파싱

- **이미지 분석 고도화**:
  - 원형 게이지 비율 측정 (OpenCV 윤곽 검출)
  - 픽셀 색상 분석으로 쿨다운 진행률 추정

---

### 3.3 스킬 대기 시간 (Skill Delay)

#### 미구현 이유
- 스킬마다 대기 시간이 다름 (즉발, 1초, 2초 등)
- 대기 시간 정보를 게임에서 제공하지 않음
- 애니메이션 길이와 실제 효과 발동 시점 불일치

#### 현재 대응 방식
- 모든 스킬에 **고정 대기 시간** 적용:
  - 스킬 사용 후 1초 대기 (코스트 UI 업데이트)
  - 안전 마진 포함 (네트워크 지연 고려)

#### 실제 영향
- 빠른 스킬도 1초 대기 → 테스트 시간 증가
- 느린 스킬은 1초로 부족할 수 있음 → 재시도로 보완

#### 보완 가능한 대안
- **스킬 데이터베이스**:
  - 캐릭터별 스킬 대기 시간 수동 측정
  - 설정 파일로 관리 (`config/skill_delays.json`)
  - 캐릭터 ID 기반 자동 조회

- **게임 데이터 접근 시**:
  - 스킬 정의 파일 파싱
  - 공식 데이터베이스 API 활용

---

### 3.4 스킬 버튼 페이징

#### 미구현 이유
- 6명 학생 중 3명씩 스킬 버튼 표시
- 페이징 버튼 인식 및 클릭 로직 복잡
- 현재 테스트는 앞 3명 스킬만 사용

#### 현재 대응 방식
- **앞 3개 슬롯만** 테스트:
  - Slot 1, 2, 3 고정 사용
  - 페이징 하지 않음

#### 실제 영향
- 뒤 3명 학생의 스킬 테스트 불가
- 전체 팀 스킬 사용 시나리오 검증 불가

#### 보완 가능한 대안
- **페이징 버튼 추가**:
  - 페이징 버튼 템플릿 준비
  - 클릭 후 슬롯 4, 5, 6 좌표로 변경
  - 전체 6개 스킬 순회 테스트

- **설정 파일 확장**:
  ```python
  # config/skill_settings.py
  SKILL_PAGES = {
      "page_1": [SLOT_1, SLOT_2, SLOT_3],
      "page_2": [SLOT_4, SLOT_5, SLOT_6]
  }
  PAGE_SWITCH_BUTTON = (x, y)
  ```

---

## 4. 네트워크 및 타이밍 제약

### 4.1 네트워크 지연

#### 제약 내용
- **문제**: 서버 응답 지연으로 UI 업데이트 지연 가능
- **영향**:
  - 화면 전환 타이밍 예측 불가
  - OCR 읽기 시점에 값이 아직 업데이트 안 됨
  - 템플릿 매칭 타임아웃 발생

#### 현재 대응 방식
- **충분한 타임아웃** 설정:
  - 화면 전환 대기: 15초
  - 전투 종료 대기: 120초
  - OCR 재시도: 5회

- **재시도 로직**:
  - 템플릿 매칭 실패 시 재시도
  - OCR 읽기 실패 시 재시도
  - 0.5초 간격으로 반복

#### 실패 사례
- 네트워크 불안정 시 타임아웃 초과
- 로딩 화면이 예상보다 길 경우

#### 보완 가능한 대안
- **동적 타임아웃**:
  - 네트워크 상태 모니터링
  - 지연 감지 시 타임아웃 자동 연장

- **로딩 화면 감지**:
  - 로딩 스피너 템플릿 매칭
  - 로딩 중에는 대기 시간 제외

---

### 4.2 타이밍 동기화

#### 제약 내용
- **문제**: 게임 내부 타이밍과 테스트 스크립트 타이밍 불일치
- **영향**:
  - 너무 빠른 클릭 → 무시됨
  - 너무 느린 클릭 → 화면 전환 놓침

#### 현재 대응 방식
- **안전 마진 추가**:
  - 클릭 전 0.5초 대기
  - 클릭 후 1초 대기
  - 화면 전환 후 2초 안정화

#### 보완 가능한 대안
- **이벤트 기반 동기화**:
  - UI 출현 감지 → 즉시 다음 단계
  - 폴링 간격 단축 (0.1초)
  - 변화 감지 알고리즘 (프레임 차이)

---

## 5. 환경 의존성

### 5.1 외부 도구 의존

#### 필수 도구
- **Tesseract OCR**:
  - Windows: UB Mannheim 빌드 설치 필요
  - 기본 경로: `C:\Program Files\Tesseract-OCR\tesseract.exe`
  - 언어팩: eng (영어)

- **Python 패키지**:
  - pyautogui (화면 제어)
  - opencv-python (이미지 처리)
  - pytesseract (OCR 래퍼)
  - pillow (이미지 로드)

#### 제약 사항
- Tesseract 미설치 시 OCR 기능 전체 사용 불가
- OpenCV 미설치 시 템플릿 매칭 신뢰도 기능 불가
- 패키지 버전 불일치 시 예상치 못한 오류

#### 현재 대응 방식
- requirements.txt로 패키지 버전 고정
- PyInstaller로 패키징 (독립 실행 파일)
- OCR 초기화 시 Tesseract 경로 자동 탐지

#### 보완 가능한 대안
- **통합 설치 패키지**:
  - Tesseract 포함 설치 프로그램
  - 자동 환경 설정 스크립트

- **대체 OCR**:
  - Windows OCR API 사용 (Tesseract 대신)
  - 클라우드 OCR API (Google Vision, Azure)

---

### 5.2 플랫폼 제약

#### 현재 지원
- **Windows 10/11** 전용
- 다른 OS에서 미테스트

#### 제약 사항
- pyautogui는 크로스 플랫폼이지만 테스트 안 됨
- 파일 경로 처리 (Windows 스타일)
- Tesseract 경로 하드코딩

#### 보완 가능한 대안
- **크로스 플랫폼 지원**:
  - pathlib 사용 (이미 적용)
  - OS별 Tesseract 경로 자동 탐지
  - Linux/macOS 테스트 및 검증

---

## 6. 검증 범위의 한계

### 6.1 정량적 검증 불가

#### 검증 불가능한 항목
- **데미지 수치**: 화면 OCR 어려움 → 간접 검증
- **HP 잔량**: 게이지 형태라 정확한 % 측정 어려움
- **크리티컬 확률**: 통계적 검증 필요하나 샘플 부족
- **버프/디버프 효과**: UI만으로 판단 어려움

#### 현재 대응 방식
- **정성적 검증**으로 대체:
  - 데미지 → 전투 승리 여부
  - HP → Victory 달성 여부
  - 버프 → 아이콘 출현 여부 (미구현)

#### 보완 가능한 대안
- **통계적 검증**:
  - 동일 전투 N회 반복
  - 승률, 평균 클리어 시간 측정
  - 이상치 탐지

- **로그 기반 검증**:
  - 게임 로그에서 정량 데이터 추출
  - CSV/JSON으로 집계
  - 기댓값과 비교

---

### 6.2 비결정적 요소

#### 제약 내용
- **전투 결과 랜덤성**:
  - 크리티컬 발생 랜덤
  - AI 행동 패턴 다양
  - 네트워크 지연 가변

- **영향**:
  - 같은 테스트가 항상 같은 결과 보장 안 됨
  - 간헐적 실패 발생 가능

#### 현재 대응 방식
- **재시도 허용**:
  - 템플릿 매칭 3회 재시도
  - OCR 읽기 5회 재시도
  - 타임아웃 충분히 설정

- **Pass/Fail 기준 완화**:
  - 핵심 기능만 필수 검증
  - 부가 기능은 선택적 검증

#### 보완 가능한 대안
- **시드 고정** (게임 지원 필요):
  - 랜덤 시드 고정으로 재현 가능한 전투
  - 테스트 모드에서 결정적 동작

- **통계적 접근**:
  - 10회 실행 중 8회 성공 → Pass
  - 신뢰 구간 계산

---

## 7. 종합 평가

### 구현 가능 항목 (✅)
- ✅ 화면 전환 검증 (템플릿 매칭)
- ✅ 버튼 클릭 및 입력 (pyautogui)
- ✅ 기본 OCR (코스트 읽기)
- ✅ 스킬 사용 및 코스트 소모 검증
- ✅ 전투 진입/종료 감지
- ✅ 결과 화면 플로우 검증
- ✅ 로그 및 스크린샷 저장

### 부분 구현 항목 (⚠️)
- ⚠️ 데미지 검증 (간접 검증만)
- ⚠️ 스킬 쿨다운 (추적 안 함, 게임 로직에 맡김)
- ⚠️ 다중 해상도 지원 (2개 해상도만)
- ⚠️ OCR 정확도 (전처리 + 재시도로 보완)

### 구현 불가 항목 (❌)
- ❌ 실시간 데미지 캡처 (기술적 한계)
- ❌ 게임 내부 변수 접근 (Live 빌드 제약)
- ❌ 메모리 조작 (치트 방지 정책)
- ❌ 100% 재현 가능한 전투 (랜덤성)

---

## 8. 권장 개선 방향

### 단기 (현재 프로젝트 범위 내)
1. 다중 조건 검증 강화 (2~3개 요소 동시 체크)
2. 실패 시 상세 로그 및 스크린샷
3. 재시도 로직 개선 (지수 백오프)

### 중기 (게임 협력 없이 가능)
1. 딥러닝 기반 UI 요소 탐지
2. 커스텀 OCR 모델 훈련
3. 비디오 녹화 후 후처리 분석

### 장기 (게임 개발팀 협력 필요)
1. 테스트 전용 API 제공
2. Debug 빌드 접근 권한
3. 게임 로그 파일 구조화된 출력
4. UI 접근성 API (Automation ID)

---

## 9. 결론

본 프로젝트는 **Live 빌드 + 화면 인식**이라는 제약 조건 하에서 **최대한 검증 가능한 범위**를 구현했습니다.

### 핵심 성과
- 스테이지 진입부터 결과 확인까지 **전체 플로우 자동화**
- OCR 기반 **스킬 코스트 검증** 시스템 구축
- 다중 조건 검증으로 **신뢰도 향상**
- 명확한 **Pass/Fail 기준** 문서화

### 인정하는 한계
- 정량적 데미지 측정 불가 → 대안: 간접 검증 (승리 여부)
- 실시간 상태 추적 불가 → 대안: UI 기반 추론
- 100% 재현성 부족 → 대안: 재시도 및 통계적 접근

### 보완 가능성
개발팀 협력 시 대부분의 제약사항을 해결할 수 있으며, 현재도 **실용적 테스트 자동화**로서 충분한 가치를 제공합니다.

---

## 문서 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2026-01-08 | 초안 작성 |
